import{_ as i,c as a,a1 as t,o as n}from"./chunks/framework.D2ql23Gy.js";const d=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"blogs/学习笔记/无章的知识/react--useEffect何时调用.md","filePath":"blogs/学习笔记/无章的知识/react--useEffect何时调用.md"}'),e={name:"blogs/学习笔记/无章的知识/react--useEffect何时调用.md"};function l(h,s,p,k,o,r){return n(),a("div",null,s[0]||(s[0]=[t(`<p>在 React 中，<code>useEffect</code> 的行为取决于它的 <strong>依赖数组</strong> ：</p><h3 id="回答核心问题-精华🔥" tabindex="-1"><strong>回答核心问题（精华🔥</strong> <a class="header-anchor" href="#回答核心问题-精华🔥" aria-label="Permalink to &quot;**回答核心问题（精华🔥**&quot;">​</a></h3><ul><li><strong>首次渲染后</strong> ：<code>useEffect</code> 一定会被调用一次。</li><li><strong>后续渲染</strong> ：是否会被调用取决于依赖数组：</li><li><strong>没有依赖数组</strong> ：每次渲染后都会调用。</li><li><strong>空依赖数组</strong> ：仅在首次渲染后调用。</li><li><strong>依赖数组带依赖</strong> ：首次渲染后调用一次，然后在依赖项变化时再次调用。</li></ul><h3 id="_1-useeffect-首次渲染时" tabindex="-1"><strong>1. <code>useEffect</code> 首次渲染时</strong> <a class="header-anchor" href="#_1-useeffect-首次渲染时" aria-label="Permalink to &quot;**1. \`useEffect\` 首次渲染时**&quot;">​</a></h3><p>无论 <code>useEffect</code> 的依赖数组内容是什么， <strong>它都会在首次渲染后被调用一次</strong> 。</p><ul><li><p><strong>示例</strong></p><div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">useEffect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;首次渲染时调用&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><ul><li>无论有没有依赖数组，这段 <code>console.log</code> 在组件首次渲染后会执行。</li></ul></li></ul><hr><h3 id="_2-是否会在后续渲染中被调用" tabindex="-1"><strong>2. 是否会在后续渲染中被调用</strong> <a class="header-anchor" href="#_2-是否会在后续渲染中被调用" aria-label="Permalink to &quot;**2. 是否会在后续渲染中被调用**&quot;">​</a></h3><p>这取决于你提供的依赖数组内容：</p><h4 id="_1-没有依赖数组" tabindex="-1"><strong>(1) 没有依赖数组</strong> <a class="header-anchor" href="#_1-没有依赖数组" aria-label="Permalink to &quot;**(1) 没有依赖数组**&quot;">​</a></h4><div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">useEffect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;每次渲染后都会调用&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><ul><li>如果你不提供依赖数组，<code>useEffect</code> 会在<strong>每次渲染后</strong>都执行，包括首次渲染和后续更新。</li></ul><hr><h4 id="_2-空依赖数组" tabindex="-1"><strong>(2) 空依赖数组</strong> <a class="header-anchor" href="#_2-空依赖数组" aria-label="Permalink to &quot;**(2) 空依赖数组**&quot;">​</a></h4><div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">useEffect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;仅在首次渲染后调用&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}, []);</span></span></code></pre></div><ul><li>如果依赖数组是空的（<code>[]</code>），<code>useEffect</code> <strong>只会在首次渲染后调用一次</strong> ，并且在组件更新时不会被调用。</li></ul><hr><h4 id="_3-带有依赖的数组" tabindex="-1"><strong>(3) 带有依赖的数组</strong> <a class="header-anchor" href="#_3-带有依赖的数组" aria-label="Permalink to &quot;**(3) 带有依赖的数组**&quot;">​</a></h4><div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">useEffect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;依赖项变化时调用&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}, [count]);</span></span></code></pre></div><ul><li><p>如果依赖数组中有变量（如 <code>count</code>），那么 <code>useEffect</code> 会在以下情况下调用：</p><ol><li><strong>首次渲染后</strong> 。</li><li><strong>依赖项 <code>count</code> 的值发生变化时</strong> 。</li></ol><p>如果 <code>count</code> 没有变化，则 <code>useEffect</code> 不会在后续渲染中调用。</p></li></ul><hr><h3 id="_3-组件卸载时的特殊情况" tabindex="-1"><strong>3. 组件卸载时的特殊情况</strong> <a class="header-anchor" href="#_3-组件卸载时的特殊情况" aria-label="Permalink to &quot;**3. 组件卸载时的特殊情况**&quot;">​</a></h3><p>无论是否有依赖数组，<code>useEffect</code> 的清理函数（如果存在）都会在组件卸载时调用。</p><div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">useEffect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> timer</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> setInterval</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;定时器运行中&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;组件卸载，清理定时器&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    clearInterval</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(timer);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  };</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}, []);</span></span></code></pre></div><ul><li><strong>在组件卸载时</strong>，<code>return</code> 的清理函数会被调用，即使依赖数组是空的。</li></ul><hr>`,26)]))}const g=i(e,[["render",l]]);export{d as __pageData,g as default};
