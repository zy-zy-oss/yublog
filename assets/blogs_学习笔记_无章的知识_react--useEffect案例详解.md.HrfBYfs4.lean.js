import{_ as i,c as a,a1 as e,o as n}from"./chunks/framework.D2ql23Gy.js";const r=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"blogs/学习笔记/无章的知识/react--useEffect案例详解.md","filePath":"blogs/学习笔记/无章的知识/react--useEffect案例详解.md"}'),l={name:"blogs/学习笔记/无章的知识/react--useEffect案例详解.md"};function t(h,s,k,p,d,E){return n(),a("div",null,s[0]||(s[0]=[e(`<p>以下是对 <code>useEffect</code> 运行时机的详细解释：</p><h4 id="一、基本概念" tabindex="-1"><strong>一、基本概念</strong> <a class="header-anchor" href="#一、基本概念" aria-label="Permalink to &quot;**一、基本概念**&quot;">​</a></h4><ul><li><code>useEffect</code> 是 React 提供的一个钩子函数，用于处理组件的副作用操作。副作用是指那些在组件渲染过程中可能影响外部环境或组件自身状态的操作，例如数据获取、订阅操作、手动修改 DOM、定时器操作等。</li></ul><h4 id="二、初次渲染时的运行" tabindex="-1"><strong>二、初次渲染时的运行</strong> <a class="header-anchor" href="#二、初次渲染时的运行" aria-label="Permalink to &quot;**二、初次渲染时的运行**&quot;">​</a></h4><ul><li>当组件首次被渲染时： <ol><li>React 会先执行组件函数，包括执行 <code>useState</code> 等其他钩子函数，完成组件的渲染。</li><li>然后，<code>useEffect</code> 钩子的回调函数会在渲染完成后被调用。在你提供的示例中：</li></ol></li></ul><div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">useEffect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> timer;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (isRunning) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        timer </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> setInterval</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            setTime</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">prevTime</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> prevTime </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (timer) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            clearInterval</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(timer);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    };</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}, [isRunning]);</span></span></code></pre></div><pre><code>- 首次渲染时，由于\`isRunning\` 的初始值为 \`true\`，\`useEffect\` 中的回调函数会被调用，创建一个定时器，因为 \`isRunning\` 为 \`true\`。
</code></pre><h4 id="三、依赖数组的作用" tabindex="-1"><strong>三、依赖数组的作用</strong> <a class="header-anchor" href="#三、依赖数组的作用" aria-label="Permalink to &quot;**三、依赖数组的作用**&quot;">​</a></h4><ul><li><code>[isRunning]</code> 是 <code>useEffect</code> 的依赖数组。它决定了 <code>useEffect</code> 何时会重新运行： <ol><li>当组件首次渲染时，<code>useEffect</code> 会运行，因为组件刚刚挂载。</li><li>当 <code>isRunning</code> 的值发生变化时，<code>useEffect</code> 会重新运行： <ul><li>如果 <code>isRunning</code> 从 <code>true</code> 变为 <code>false</code>： <ul><li>首先，<code>useEffect</code> 的返回函数会被调用，清除之前创建的定时器（如果存在），因为 <code>isRunning</code> 的变化会触发 <code>useEffect</code> 的清理操作。</li><li>然后，新的 <code>useEffect</code> 回调函数会被调用，但由于 <code>isRunning</code> 现在是 <code>false</code>，不会创建新的定时器。</li></ul></li><li>如果 <code>isRunning</code> 从 <code>false</code> 变为 <code>true</code>： <ul><li>同样，<code>useEffect</code> 的返回函数会先被调用（但此时没有要清理的定时器）。</li><li>然后，新的 <code>useEffect</code> 回调函数会被调用，由于 <code>isRunning</code> 为 <code>true</code>，会创建一个新的定时器。</li></ul></li></ul></li></ol></li></ul><h4 id="四、组件卸载时的运行" tabindex="-1"><strong>四、组件卸载时的运行</strong> <a class="header-anchor" href="#四、组件卸载时的运行" aria-label="Permalink to &quot;**四、组件卸载时的运行**&quot;">​</a></h4><ul><li>当组件即将从 DOM 中卸载时： <ol><li><code>useEffect</code> 的返回函数会被调用，用于清理操作。在这个例子中，它会检查 <code>timer</code> 是否存在，如果存在则清除定时器。这是防止内存泄漏的重要步骤，因为如果定时器不清除，它会继续在后台运行，即使组件已经不在 DOM 中。</li></ol></li></ul><h4 id="五、多次渲染时的情况" tabindex="-1"><strong>五、多次渲染时的情况</strong> <a class="header-anchor" href="#五、多次渲染时的情况" aria-label="Permalink to &quot;**五、多次渲染时的情况**&quot;">​</a></h4><ul><li>假设 <code>isRunning</code> 状态在组件的生命周期内多次改变： <ol><li>每次 <code>isRunning</code> 的值改变，都会触发 <code>useEffect</code> 的清理操作（调用返回函数），然后重新运行 <code>useEffect</code> 的回调函数。</li><li>例如，如果 <code>isRunning</code> 在 <code>true</code> 和 <code>false</code> 之间切换多次： <ul><li>每次从 <code>true</code> 变为 <code>false</code>，都会调用 <code>clearInterval(timer)</code> 清除定时器。</li><li>每次从 <code>false</code> 变为 <code>true</code>，都会重新创建一个新的定时器。</li></ul></li></ol></li></ul><h4 id="六、与状态更新的关系" tabindex="-1"><strong>六、与状态更新的关系</strong> <a class="header-anchor" href="#六、与状态更新的关系" aria-label="Permalink to &quot;**六、与状态更新的关系**&quot;">​</a></h4><ul><li><code>useEffect</code> 的运行可能会导致状态更新： <ol><li>在 <code>useEffect</code> 的回调函数中，调用 <code>setTime((prevTime) =&gt; prevTime + 1)</code> 会更新 <code>time</code> 状态。</li><li>当 <code>time</code> 状态更新时，会触发组件的重新渲染，但 <code>useEffect</code> 只会在 <code>isRunning</code> 改变时重新运行，因为它只依赖 <code>isRunning</code>。</li></ol></li></ul><h4 id="七、示例代码的运行世纪解释" tabindex="-1"><strong>七、示例代码的运行世纪解释</strong> <a class="header-anchor" href="#七、示例代码的运行世纪解释" aria-label="Permalink to &quot;**七、示例代码的运行世纪解释**&quot;">​</a></h4><ul><li>在你的代码中： <ol><li>组件首次渲染： <ul><li><code>useEffect</code> 启动定时器，因为 <code>isRunning</code> 为 <code>true</code>。</li></ul></li><li>点击 <code>暂停定时器</code> 或 <code>启动定时器</code> 按钮： <ul><li><code>handleToggle</code> 函数被调用，更新 <code>isRunning</code> 状态。</li><li>这会触发 <code>useEffect</code> 的清理和重新运行。</li><li>如果 <code>isRunning</code> 变为 <code>false</code>，定时器会被清除；如果 <code>isRunning</code> 变为 <code>true</code>，定时器会重新启动。</li></ul></li></ol></li></ul><p>总结来说，<code>useEffect</code> 在组件的整个生命周期中的运行是根据其依赖数组中的依赖项的变化而变化的，并且它提供了一种机制来执行清理操作，确保组件在多次渲染和卸载时，副作用操作能够正确处理，避免内存泄漏和不一致的状态更新。</p><p>如果你想在 <code>useEffect</code> 中添加更多的操作，例如数据获取，可以根据类似的逻辑添加相应的代码，并确保考虑清理操作，以保证组件的稳定性和性能。例如：</p><div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">useEffect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> timer;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (isRunning) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        timer </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> setInterval</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            setTime</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">prevTime</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> prevTime </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fetchData</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> async</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        try</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> response</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> await</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fetch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;https://api.example.com/data&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> await</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> response.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">json</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            // 处理获取到的数据，例如更新状态</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">catch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (error) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">error</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Error fetching data:&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, error);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    };</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    fetchData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (timer) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            clearInterval</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(timer);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 可以添加数据获取的清理操作，例如取消订阅或清理请求</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    };</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}, [isRunning]);</span></span></code></pre></div><p>在这个扩展的例子中，不仅有定时器操作，还有异步的数据获取操作，并且都遵循 <code>useEffect</code> 的运行规则和清理逻辑。</p><p>希望这个详细的解释能帮助你更好地理解 <code>useEffect</code> 的运行机制，如果你有其他问题或需要进一步的帮助，请随时告诉我。</p>`,22)]))}const o=i(l,[["render",t]]);export{r as __pageData,o as default};
